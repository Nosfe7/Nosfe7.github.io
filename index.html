<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Survival Game</title>
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);

			}
			
			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ff0000;
				text-align: center;

				cursor: pointer;

			}
		</style>
	</head>
	<body>
		<script src="ThreeJS\build\three.js"></script>
		<script src="ThreeJS\examples\js\controls\PointerLockControls.js"></script>
		<script src="ThreeJS\examples\js\libs\stats.min.js"></script>
		<script src="js\FPSControls.js"></script>
		<script src="js\ParticleEngine.js"></script>
		<script src="js\jquery-1.11.3.js"></script>
		<script src="js\loadShader.js"></script>
		
		
		<div id="blocker">

			<div id="instructions">
				<span style="font-size:40px">Click to play</span>
				<br />
				(W, A, S, D = Move,  MOUSE = Look around)
			</div>

		</div>
		
		<script>
		
			 // variabili globali per la camera, la scena, luce, ecc..
            var camera, camera2; 
			var controls;
			var scene, renderer;
			var light, radiusModifier;
			var torch; 
			var stats; 
			var speed; 
			var particleEngine;
			var timer;
			
		
		
			init();
			animate();
		

			//controlla la distanza di propagazione della luce
			function lightControl(radius){
			
	
				radius -= 0.0000002;
			
				if (radius <= 0)
					radius = 0;
					
				return radius
			
			}
		
		
            // INIZIALIZZAZIONE
  

		
            // INIZIALIZZAZIONE
            function init() {
		
				//Settaggio scena, camera e renderer
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
				//camera2 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
				
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);
				
				//Piano
				var planeGeometry = new THREE.BoxGeometry(500, 2, 500);
				
				var texture = THREE.ImageUtils.loadTexture( 'textures/ground3.jpg');
				var bump = THREE.ImageUtils.loadTexture('textures/ground3b.jpg');
				
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set( 500, 500 );
				
				bump.wrapS = THREE.RepeatWrapping;
				bump.wrapT = THREE.RepeatWrapping;
				bump.repeat.set( 500, 500 );
				
				var planeMaterial = new THREE.MeshPhongMaterial( {map: texture, bumpMap: bump, bumpScale: 0.2} );
				var plane = new THREE.Mesh(planeGeometry,planeMaterial);
				
				plane.position.y = 0;
				scene.add(plane);
				
				
				//Muro 
				var geometry = new THREE.BoxGeometry (2, 2, 2);

				
				var texture = THREE.ImageUtils.loadTexture( 'textures/wall2.jpg');
				var bump = THREE.ImageUtils.loadTexture('textures/wall2b.jpg');
				//var normal = THREE.ImageUtils.loadTexture('textures/wall2n.jpg');
				
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set( 4, 4);
				
				bump.wrapS = THREE.RepeatWrapping;
				bump.wrapT = THREE.RepeatWrapping;
				bump.repeat.set( 4, 4);
				
				var material = new THREE.MeshPhongMaterial( {map:texture,  bumpMap: bump, bumpScale: 0.2} );
				var cube = new THREE.Mesh(geometry,material);				
				
				scene.add(cube);
				cube.position.z = -1;
				cube.position.y = 2;


				// Statistiche
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				document.body.appendChild( stats.domElement );
				
				
				//Controlli FPS 
				
				speed = 0.01
				
				controls = new FPSControls(camera,speed);
				controls.PLObject.position.set(1,2,2);
				
				scene.add(controls.PLObject);

				/*//Camera secondaria (per debugging)
				scene.add(camera2);
				camera2.position.set(1,1,4);*/
				
				//Luce
				light = new THREE.PointLight( 0xFFB90F,1,5,2);
				
				/*light.shadowDarkness = 0.5;
				light.castShadow = true;
				light.shadowMapWidth = 2048; 
				light.shadowMapHeight = 2048;*/
				
				//Ombre 
				renderer.shadowMapEnabled = false;
				
				//Torcia
				var loader = new THREE.JSONLoader();
				torch = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/Torch.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						var texture = THREE.ImageUtils.loadTexture('models/maps/TorchUV.png');
						
						var material = new THREE.MeshLambertMaterial({map:texture});
						geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						torch.add(mesh);
					}
				);
				
				
				
				
				
				
				
				//Gerarchia: camera->torcia->luce e fiamma
				camera.add(torch);
				torch.position.set(0,-0.35,-0.7);
				
				//Fiamma

				flamePos = new THREE.Vector3(0.332,-0.075, 0.234);
				
				var flameHeight = 0.8;
				var flameWidth = 0.012;
				
				particleEngine = new FlameParticleEngine(500, 30, flamePos, torch, flameHeight, flameWidth );

				
				particleEngine.init();
				
				
				//Luce
				torch.add(light);
				light.position.set(0.5,0.5,0.3);
				
				radiusModifier = 1;
				
				//Ogni oggetto della scena deve produrre un'ombra quando interagisce con la luce
				scene.traverse( function( node ) {
					
					if ( node instanceof THREE.Object3D ) {

						node.castShadow = false;
						node.receiveShadow = false;
					}

				} );
				
				
				//Timer
				timer = new THREE.Clock(true);
			}
			
			
			
			// RENDERING
			
            // Animate si occupa di richiedere un nuovo frame, di gestire gli update, e poi di chiamare la funzione di rendering
			function animate() {

				//Richiede un nuovo frame
				requestAnimationFrame(animate);
			
				//Aggiorna lo stato dei controlli
               	controls.update();
		
				//Aggiorna statistiche 
				stats.update(renderer);
				
				//Aggiorna particle engine
				particleEngine.update()

				
				//Chiama la funzione di rendering
				render();
			

				//Luce
				radiusModifier = lightControl(radiusModifier);
			
			
				light.distance *=radiusModifier;
			

				//Intensità della luce è modificata da una funzione coseno per dare un effetto di lampeggiamento
				light.intensity = (Math.cos(timer.getElapsedTime()*(20))/(10)) + 1;

				//Tempo trascorso in secondi
			
				light.intensity = (Math.cos(timer.getElapsedTime()*20)/10) + 1;

            }
			
			//Evento resize delle finestra
			function onWindowResize() {
				
				//Aggiorno i dati della camera 
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
		 
				renderer.setSize( window.innerWidth, window.innerHeight);
		 
				render();
 
			}
			
			
			//Rendering della scena
			function render(){
				
				
				renderer.render(scene, camera);
				
			}
			
			
			
			
		</script>
	</body>
</html>
