<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Survival Game</title>
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);

			}
			
			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ff0000;
				text-align: center;

				cursor: pointer;

			}
		</style>
	</head>
	<body>
		<script src="ThreeJS\build\three.js"></script>
		<script src="ThreeJS\examples\js\controls\PointerLockControls.js"></script>
		<script src="ThreeJS\examples\js\libs\stats.min.js"></script>
		<script src="js\FPSControls.js"></script>
		<script src="js\ParticleEngine.js"></script>
		<script src="js\jquery-1.11.3.js"></script>
		<script src="js\loadShader.js"></script>
		
		
		<div id="blocker">

			<div id="instructions">
				<span style="font-size:40px">Click to play</span>
				<br />
				(W, A, S, D = Move,  MOUSE = Look around)
			</div>

		</div>
		
		<script>
		
			 // variabili globali per la camera, la scena, luce, ecc..
            var camera, camera2; 
			var controls;
			var cube;
			var cube2
			var scene, renderer;
			var light, radiusModifier;
			var torch; 
			var stats; 
			var speed; 
			var particleEngine;
			var timer;

			var playerBB;
			var wallBB;
			var wall2BB;
			var wallsBBs;
			
			var level1WallsPos;
			var level2WallsPos;
			
		
		
			init();
			animate();
		

			//controlla la distanza di propagazione della luce
			function lightControl(radius){
			
	
				radius -= 0.000000002;
			
				if (radius <= 0)
					radius = 0;
					
				return radius
			
			}
			
			
            // INIZIALIZZAZIONE
            function init() {
		
				//Settaggio scena, camera e renderer
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
				//camera2 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
			

				
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);
				
				
				//Posizioni muri livello 1
				
				level1WallsPos = [new THREE.Vector3(0,2,-1), new THREE.Vector3(2,2,-1), new THREE.Vector3(2,2,-3), new THREE.Vector3(-2,2,-1),
								  new THREE.Vector3(-4,2,-1), new THREE.Vector3(-6,2,-1), new THREE.Vector3(-6,2,1),
								  new THREE.Vector3(-6,2,-3), new THREE.Vector3(-2,2,-3), new THREE.Vector3(2,2,-5),
								  new THREE.Vector3(8,2,-5), new THREE.Vector3(-6,2,5), new THREE.Vector3(-6,2,7),
								  new THREE.Vector3(-6,2,3), new THREE.Vector3(-4,2,5), new THREE.Vector3(-2, 2, 5),
								  new THREE.Vector3(-4, 2, 7), new THREE.Vector3(-2, 2, 7), new THREE.Vector3(4,2,-1),
								  new THREE.Vector3(6,2,-1), new THREE.Vector3(8,2,-3), new THREE.Vector3(8,2,-1),
								  new THREE.Vector3(8,2,1), new THREE.Vector3(8,2,3), new THREE.Vector3(8,2,5), 
								  new THREE.Vector3(6,2,5), new THREE.Vector3(4,2,5), new THREE.Vector3(4,2,5),
								  new THREE.Vector3(4,2,7), new THREE.Vector3(6,2,7), new THREE.Vector3(8,2,7),
								  new THREE.Vector3(-8,2,7), new THREE.Vector3(-10,2,7), new THREE.Vector3(-12,2,7), 
								  new THREE.Vector3(-14,2,9), new THREE.Vector3(-14,2,11), new THREE.Vector3(-12,2,13), 
								  new THREE.Vector3(-10,2,13), new THREE.Vector3(-10,2,15), new THREE.Vector3(-10,2,17), 
								  new THREE.Vector3(-8,2,19), new THREE.Vector3(-6,2,19), new THREE.Vector3(-4,2,17), 
								  new THREE.Vector3(-4,2,15), new THREE.Vector3(-4,2,13), new THREE.Vector3(-2,2,13), 
								  new THREE.Vector3(-2,2,13), new THREE.Vector3(0,2,13), new THREE.Vector3(2,2,13), 
								  new THREE.Vector3(4,2,13), new THREE.Vector3(6,2,13), new THREE.Vector3(6,2,15),
								  new THREE.Vector3(6,2,17), new THREE.Vector3(6,2,19), new THREE.Vector3(8,2,21),
								  new THREE.Vector3(10,2,21), new THREE.Vector3(12,2,19), new THREE.Vector3(12,2,17), 
								  new THREE.Vector3(12,2,15), new THREE.Vector3(12,2,13), new THREE.Vector3(14,2,13), 
								  new THREE.Vector3(14,2,11), new THREE.Vector3(14,2,9), new THREE.Vector3(14,2,7), 
								  new THREE.Vector3(14,2,5), new THREE.Vector3(12,2,3)];
								  
				
								  
				//Posizioni muri livello 2
				
				level2WallsPos = [new THREE.Vector3(12,2,1), new THREE.Vector3(10,2,-3), new THREE.Vector3(12, 2, -3),
								  new THREE.Vector3(12,2,-5), new THREE.Vector3(14,2,-7), new THREE.Vector3(16,2,-7),
								  new THREE.Vector3(18,2,-7), new THREE.Vector3(18,2,-9), new THREE.Vector3(18,2,-11), 
								  new THREE.Vector3(20,2,-13), new THREE.Vector3(22,2,-11), new THREE.Vector3(22,2,-9),
								  new THREE.Vector3(22,2,-7), new THREE.Vector3(22,2,-5), new THREE.Vector3(22,2,-3),
								  new THREE.Vector3(20,2,-3), new THREE.Vector3(18,2,-3), new THREE.Vector3(16,2,-3),
								  new THREE.Vector3(24,2,-13), new THREE.Vector3(26,2,-11),
								  new THREE.Vector3(26,2,-9), new THREE.Vector3(26,2,-7),
								  new THREE.Vector3(26,2,-5), new THREE.Vector3(26,2,-3), new THREE.Vector3(26,2,-1), 
								  new THREE.Vector3(26,2,1), new THREE.Vector3(26,2,3), new THREE.Vector3(24,2,5), 
								  new THREE.Vector3(24,2,7), new THREE.Vector3(24,2,9), new THREE.Vector3(26,2,9),
								  new THREE.Vector3(26,2,13), new THREE.Vector3(24,2,13), new THREE.Vector3(22,2,13),
								  new THREE.Vector3(20,2,13), new THREE.Vector3(18,2,13), new THREE.Vector3(16,2,13),
								  new THREE.Vector3(14,2,13), new THREE.Vector3(12,2,13), new THREE.Vector3(10,2,11),
								  new THREE.Vector3(12,2,9), new THREE.Vector3(14,2,9), new THREE.Vector3(16,2,9), new THREE.Vector3(18,2,9),
								  new THREE.Vector3(20,2,9), new THREE.Vector3(20,2,7), new THREE.Vector3(20,2,5),
								  new THREE.Vector3(18,2,5), new THREE.Vector3(16,2,5), new THREE.Vector3(14,2,5), 
								  new THREE.Vector3(12,2,3), new THREE.Vector3(14,2,1), new THREE.Vector3(16,2,1),
								  new THREE.Vector3(18,2,1), new THREE.Vector3(20,2,1), new THREE.Vector3(22,2,1)];
								  
				
				
								  
				
				//Piano
				var planeGeometry = new THREE.BoxGeometry(500, 2, 500);
				
				var texture = THREE.ImageUtils.loadTexture( 'textures/ground3.jpg');
				var bump = THREE.ImageUtils.loadTexture('textures/ground3b.jpg');
				
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set( 500, 500 );
				
				bump.wrapS = THREE.RepeatWrapping;
				bump.wrapT = THREE.RepeatWrapping;
				bump.repeat.set( 500, 500 );
				
				var planeMaterial = new THREE.MeshPhongMaterial( {map: texture, bumpMap: bump, bumpScale: 0.2} );
				var plane = new THREE.Mesh(planeGeometry,planeMaterial);
				
				plane.position.y = 0;
				scene.add(plane);
				
				
				//Caricamento muri
				var geometry = new THREE.BoxGeometry (2, 2, 2);

				
				var texture = THREE.ImageUtils.loadTexture( 'textures/wall2.jpg');
				var bump = THREE.ImageUtils.loadTexture('textures/wall2b.jpg');
	
				
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set( 4, 4);
				
				bump.wrapS = THREE.RepeatWrapping;
				bump.wrapT = THREE.RepeatWrapping;
				bump.repeat.set( 4, 4);
				

				var material = new THREE.MeshPhongMaterial( {map:texture,  bumpMap: bump, bumpScale: 0.2} );
				
				wallsBBs = new Array();
				
				
				for (i=0; i< level1WallsPos.length; i++) {
					
					wall = new THREE.Mesh(
						geometry,
						material);
					
					scene.add(wall);
					
					wall.position.x = level1WallsPos[i].x;
					wall.position.y = level1WallsPos[i].y;
					wall.position.z = level1WallsPos[i].z;
					
					wallsBBs.push(new THREE.Box3().setFromCenterAndSize(wall.position, new THREE.Vector3(2,2,2)));
				}
				
				for (i=0; i< level2WallsPos.length; i++) {
					
					wall = new THREE.Mesh(
						geometry,
						material);
					
					scene.add(wall);
					
					wall.position.x = level2WallsPos[i].x;
					wall.position.y = level2WallsPos[i].y;
					wall.position.z = level2WallsPos[i].z;
					
					wallsBBs.push(new THREE.Box3().setFromCenterAndSize(wall.position, new THREE.Vector3(2,2,2)));
				}
				
				//Muro uscita stanza 1
				var transparentMaterial = new THREE.MeshPhongMaterial( {map:texture,  bumpMap: bump, bumpScale: 0.2, opacity : 1.0, transparent : true} );
				cube = new THREE.Mesh(geometry,transparentMaterial);	

				scene.add(cube);
				cube.position.set(10,2,3); 
				
				//Muro uscita stanza 2
				var transparentMaterial2 = new THREE.MeshPhongMaterial( {map:texture,  bumpMap: bump, bumpScale: 0.2, opacity : 1.0, transparent : true} );
				cube2 = new THREE.Mesh(geometry,transparentMaterial2);	

				scene.add(cube2);
				cube2.position.set(28,2,11);
				
				//colliders muri uscita boundary box,
				wallBB = new THREE.Box3().setFromCenterAndSize(cube.position, new THREE.Vector3(4,4,4));
				wall2BB = new THREE.Box3().setFromCenterAndSize(cube2.position, new THREE.Vector3(4,4,4));
				


				// Statistiche
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				document.body.appendChild( stats.domElement );
				

				//Controlli FPS 
				
				speed = 0.01
				
				controls = new FPSControls(camera,speed);
				
				controls.PLObject.position.set(12,2,-1); 
				
				scene.add(controls.PLObject);

				/*//Camera secondaria (per debugging)
				scene.add(camera2);
				camera2.position.set(1,1,4);*/
				
				//Luce
				light = new THREE.PointLight( 0xFFB90F,1,5,2);
				
				/*light.shadowDarkness = 0.5;
				light.castShadow = true;
				light.shadowMapWidth = 2048; 
				light.shadowMapHeight = 2048;*/
				
				//Ombre 
				renderer.shadowMapEnabled = false;
				
				//Torcia
				var loader = new THREE.JSONLoader();
				torch = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/Torch.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						var texture = THREE.ImageUtils.loadTexture('models/maps/TorchUV.png');
						
						var material = new THREE.MeshLambertMaterial({map:texture});
						geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						torch.add(mesh);
					}
				);
				
				
								
				
				//Gerarchia: camera -> bounding box e camera->torcia->luce e fiamma
				camera.add(torch);
				torch.position.set(-0.1,-0.35,-0.65);

				
				
				//Fiamma

				flamePos = new THREE.Vector3(0.332,-0.075, 0.234);
				
				var flameHeight = 0.8;
				var flameWidth = 0.012;
				
				particleEngine = new FlameParticleEngine(500, 30, flamePos, torch, flameHeight, flameWidth );

				
				particleEngine.init();
				
				
				//Luce
				torch.add(light);
				light.position.set(0.5,0.5,0.3);
				
				radiusModifier = 1;
				
				/*//Ogni oggetto della scena deve produrre un'ombra quando interagisce con la luce
				scene.traverse( function( node ) {
					
					if ( node instanceof THREE.Object3D ) {

						node.castShadow = false;
						node.receiveShadow = false;
					}

				} );*/
				
				
				//Timer
				timer = new THREE.Clock(true);
				
				
				//INDIZI
				
				
				//Livello 1
				arrow = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						//var texture = THREE.ImageUtils.loadTexture('models/maps/TorchUV.png');
						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0xff0000), specular: new THREE.Color(0x00ff00), shininess:100});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow.add(mesh);
					}
				);
				
				scene.add(arrow);
				arrow.position.set(-7,1.05,10);
				arrow.rotation.y-= 180 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				
				
				arrow1 = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {

						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0x00ff00), shininess : 0});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow1.add(mesh);
					}
				);
				
				scene.add(arrow1);
				arrow1.position.set(1,1.05,8);
				arrow1.rotation.y-= 90 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				arrow2 = new THREE.Object3D();0xffff00
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {

						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0xffff00), specular:new THREE.Color(0Xff0000), shininess : 100});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow2.add(mesh);
					}
				);
				
				scene.add(arrow2);
				arrow2.position.set(3,1.05,10);
				arrow2.rotation.y-= 180 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				
				
				
				arrow3 = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {

						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0xff7700)});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow3.add(mesh);
					}
				);
				
				scene.add(arrow3);
				arrow3.position.set(10,1.05,8);
				arrow3.rotation.y-= 90 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				
				arrow5 = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0xff0000)});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow5.add(mesh);
					}
				);
				
				scene.add(arrow5);
				arrow5.position.set(8,1.05,12);
				arrow5.rotation.y+= 90 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				
				
				//Livello 2
				arrow6 = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						//var texture = THREE.ImageUtils.loadTexture('models/maps/TorchUV.png');
						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0x00ff00), specular: new THREE.Color(0xff0000), shininess:100});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow6.add(mesh);
					}
				);
				
				scene.add(arrow6);
				arrow6.position.set(16.5,1.05,-1);
				arrow6.rotation.y-= 180 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				arrow7 = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						//var texture = THREE.ImageUtils.loadTexture('models/maps/TorchUV.png');
						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0xff0000),  shininess:100});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow7.add(mesh);
					}
				);
				
				scene.add(arrow7);
				arrow7.position.set(14,1.05,-3);
				arrow7.rotation.y-= 90 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				
				arrow8 = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						//var texture = THREE.ImageUtils.loadTexture('models/maps/TorchUV.png');
						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0xffff00),  shininess:100});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow8.add(mesh);
					}
				);
				
				scene.add(arrow8);
				arrow8.position.set(24,1.05,-3);
				arrow8.rotation.y-= 90 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				arrow9 = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						//var texture = THREE.ImageUtils.loadTexture('models/maps/TorchUV.png');
						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0xFF8000), specular: new THREE.Color(0x32cd32),  shininess:100});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow9.add(mesh);
					}
				);
				
				scene.add(arrow9);
				arrow9.position.set(24,1.05,1);
				arrow9.rotation.y+= 90 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				arrow10 = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						//var texture = THREE.ImageUtils.loadTexture('models/maps/TorchUV.png');
						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0xffff00), specular : new THREE.Color(0xffff00), shininess:100});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow10.add(mesh);
					}
				);
				
				scene.add(arrow10);
				arrow10.position.set(22,1.05,5);
				arrow10.rotation.y+= 90 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				
				arrow11 = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						//var texture = THREE.ImageUtils.loadTexture('models/maps/TorchUV.png');
						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0xff558b),  shininess:0});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow11.add(mesh);
					}
				);
				
				scene.add(arrow11);
				arrow11.position.set(20,1.05,3);
				//arrow11.rotation.y+= 180 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				arrow12 = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						//var texture = THREE.ImageUtils.loadTexture('models/maps/TorchUV.png');
						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0xffff00),  shininess:0});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow12.add(mesh);
					}
				);
				
				scene.add(arrow12);
				arrow12.position.set(24,1.05,11);
				arrow12.rotation.y+= 180 * Math.PI / 180; //converto da radianti a gradi con Pi/180
				
				arrow13 = new THREE.Object3D();
				
				loader.load(
					// Path dell'oggetto da caricare in formato json
					'models/sign.json',
					// Funzione da richiamare quando l'oggetto è caricato
					function ( geometry) {
						//var texture = THREE.ImageUtils.loadTexture('models/maps/TorchUV.png');
						
						var material = new THREE.MeshPhongMaterial({color:new THREE.Color(0x00ff00),  shininess:0});
						//geometry.scale(1/10,1/10,1/10);
						var mesh = new THREE.Mesh( geometry, material );		
						arrow13.add(mesh);
					}
				);
				
				scene.add(arrow13);
				arrow13.position.set(20,1.05,11);
				//arrow13.rotation.y+= 180 * Math.PI / 180; //converto da radianti a gradi con Pi/180
			
			}
			
			
			
			// RENDERING
			
            // Animate si occupa di richiedere un nuovo frame, di gestire gli update, e poi di chiamare la funzione di rendering
			function animate() {

				//Richiede un nuovo frame
				requestAnimationFrame(animate);
			
				//Aggiorna lo stato dei controlli
               	controls.update();
		
				//Aggiorna statistiche 
				stats.update(renderer);
				
				//Aggiorna particle engine
				particleEngine.update()

				//Controlla intersezione con muro
				
					//1)Genero il frustum dalla matrice del  view space moltiplicata per la matrice di proiezione
					var frustumMatrix = new THREE.Matrix4().multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
					
					var frustum = new THREE.Frustum().setFromMatrix(frustumMatrix);
				
					//2)Bounding Box intorno al personaggio
					playerBB = new THREE.Box3().setFromCenterAndSize(controls.PLObject.position, new THREE.Vector3(1,1,1));

				
				/*se c'è intersezione con entrambi (il giocatore è di fronte al muro principale e vicino ad esso, 
				/il muro principale diventa gradualmente trasparente e poi viene rimosso dalla scena*/
				
				
				for (i=0; i<scene.children.length; i++){ //controlla prima se il cubo esiste ancora nella scena 
					if (scene.children[i] == cube){
						
				
						if (playerBB.isIntersectionBox(wallBB) && frustum.intersectsObject(cube)){
							cube.material.opacity -= 0.03;
							
						
							if (cube.material.opacity <= 0){
								cube.material.opacity = 0;
								scene.remove(cube);
							}
							
						}
					}
					
					if (scene.children[i] == cube2){
						
				
						if (playerBB.isIntersectionBox(wall2BB) && frustum.intersectsObject(cube2)){
							cube2.material.opacity -= 0.03;
							
						
							if (cube2.material.opacity <= 0){
								cube2.material.opacity = 0;
								scene.remove(cube2);
							}
							
						}
					}
				}					

				
				
				//Se c'è intersezione con un muro della stanza, controlla dov'è l'intersezione, e blocca il movimento del personaggio
				var maxIntersectionSize = new THREE.Vector3(0,0,0);
				var maxIndex = 0;
				
				
				for (i=0; i < wallsBBs.length; i++)
					if (playerBB.isIntersectionBox(wallsBBs[i])){
					
						var intersectionSize = playerBB.intersect (wallsBBs[i]).size();
					
					
					
						if ((intersectionSize.x * intersectionSize.z) >= (maxIntersectionSize.x * maxIntersectionSize.z)){
							maxIndex = i;
							maxIntersectionSize = intersectionSize;
							
							
						}
						
						

					}
					
				
					
				if (playerBB.min.x <= wallsBBs[maxIndex].max.x && playerBB.min.x > wallsBBs[maxIndex].min.x
					&& maxIntersectionSize.x < maxIntersectionSize.z)
							
							controls.PLObject.position.x = wallsBBs[maxIndex].max.x + 0.5;
					
				else if (playerBB.max.x >= wallsBBs[maxIndex].min.x && playerBB.max.x < wallsBBs[maxIndex].max.x
					&& maxIntersectionSize.x < maxIntersectionSize.z)
					
					controls.PLObject.position.x = wallsBBs[maxIndex].min.x - 0.5;
				
				if (playerBB.min.z <= wallsBBs[maxIndex].max.z && playerBB.min.z > wallsBBs[maxIndex].min.z
					&& maxIntersectionSize.z < maxIntersectionSize.x)
					
					controls.PLObject.position.z = wallsBBs[maxIndex].max.z + 0.5;
					
				else if (playerBB.max.z >= wallsBBs[maxIndex].min.z && playerBB.max.z < wallsBBs[maxIndex].max.z 
					&& maxIntersectionSize.z < maxIntersectionSize.x)
					
					controls.PLObject.position.z = wallsBBs[maxIndex].min.z - 0.5;
				
				
				
				
				
				//Chiama la funzione di rendering
				render();
			

				//Luce
				radiusModifier = lightControl(radiusModifier);
			
			
				light.distance *=radiusModifier;
			

				//Intensità della luce è modificata da una funzione coseno per dare un effetto di lampeggiamento
				light.intensity = (Math.cos(timer.getElapsedTime()*(20))/(10)) + 1;

            }
			
			//Evento resize delle finestra
			function onWindowResize() {
				
				//Aggiorno i dati della camera 
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
		 
				renderer.setSize( window.innerWidth, window.innerHeight);
		 
				render();
 
			}
			
			
			//Rendering della scena
			function render(){
				
				
				renderer.render(scene, camera);
				
			}
			
			
			
			
		</script>
	</body>
</html>
